'''[산책]
문제 설명 
여름이는 강아지를 산책시키려고 합니다. 
여름이는 2차원 좌표평면에서 동/서/남/북 방향으로 
1m 단위로 이동하면서 강아지를 산책시킵니다. 
산책루트가 담긴 문자열 route가 주어질 때, 
도착점의 위치를 return하도록 빈칸을 채워 solution함수를 완성해 주세요.
route는 "N", "S", "E", "W"로 이루어져 있습니다.
"N"은 북쪽으로 1만큼 움직입니다.
"S"는 남쪽으로 1만큼 움직입니다.
북쪽으로 -1만큼 움직인 것과 같습니다.
"E"는 동쪽으로 1만큼 움직입니다.
"W"는 서쪽으로 1만큼 움직입니다.
동쪽으로 -1만큼 움직인 것과 같습니다.
출발점으로부터 [동쪽으로 떨어진 거리, 북쪽으로 떨어진 거리]형태로 강아지의 최종 위치를 구해서 return해야 합니다.
출발점을 기준으로 서쪽, 남쪽에 있는 경우는 동쪽, 북쪽으로 음수만큼 떨어진 것으로 표현합니다.
출발점으로부터 동쪽으로 2, 북쪽으로 3만큼 떨어졌다면 [2, 3]을 return 합니다.
출발점으로부터 서쪽으로 1, 남쪽으로 4만큼 떨어졌다면 [-1, -4]를 return 합니다.

제한사항
1 ≤ route의 길이 ≤ 20
route는 "N", "S", "E", "W"로만 이루어져 있습니다.

입출력 예
route	result
"NSSNEWWN"	[-1, 1]
"EESEEWNWSNWWNS"	[0, 0]

입출력 예 설명
입출력 예 #1
"NSSNEWWN" 순서대로 움직이면 서쪽으로 1, 북쪽으로 1만큼 떨어진 곳에 도착하게 되므로 [-1, 1]을 return합니다.
입출력 예 #2
"EESEEWNWSNWWNS" 순서대로 움직이면 출발지와 같은 곳으로 돌아오므로 [0, 0]을 return합니다.
'''



'''[병과분류]
문제 설명
퓨쳐종합병원에서는 접수한 환자가 진료받을 병과에 따라 자동으로 환자 코드를 부여해 주는 프로그램이 있습니다. 
환자 코드의 마지막 네 글자를 보면 환자가 어디 병과에서 진료를 받아야 할지 알 수 있습니다. 
예를 들어 환자의 코드가 "_eye"로 끝난다면 안과를, 
"head"로 끝난다면 신경외과 진료를 보게 됩니다.
 환자 코드의 마지막 글자에 따른 병과 분류 기준은 다음과 같습니다.

마지막글자 | 병과
"_eye"	"Ophthalmologyc"
"head"	"Neurosurgery"
"infl"	"Orthopedics"
"skin"	"Dermatology"
환자의 코드를 나타내는 문자열 code를 입력받아 위 표에 맞는 병과를 출력하도록 빈칸을 채워 코드를 완성해 주세요. 
위 표의 단어로 끝나지 않는다면 "direct recommendation"를 출력합니다.

제한사항
4 ≤ code의 길이 ≤ 20
code는 영어 소문자와 숫자, 언더바("_")로 이루어져 있습니다.
입출력 예
입력 #1
dry_eye
출력 #1
Ophthalmologyc
입력 #2
pat23_08_20_head
출력 #2
Neurosurgery

입출력 예 설명
입출력 예 #1
code가 "_eye"로 끝나기 때문에 "Ophthalmologyc"를 출력합니다.
입출력 예 #2
code가 "head"로 끝나기 때문에 "Neurosurgery"를 출력합니다.
'''



'''[닉네임 규칙]
문제 설명
온라인 서비스를 이용하기 위해서 닉네임이 필요합니다. 
이때 닉네임이 될 수 있는 조건은 다음과 같습니다.
닉네임의 길이가 4자 이상 8자 이하여야합니다.
닉네임에는 소문자 l과w, 대문자 O와 W를 사용할 수 없습니다.
이외의 영어 대소문자와 숫자는 모두 사용이 가능합니다.
주어진 solution 함수는 사용할 수 없는 닉네임 nickname을 받아 
사용할 수 있는 닉네임으로 바꿔주는 함수입니다. 
이때 닉네임을 변경하는 규칙은 다음과 같으며 첫 번째 규칙부터 순서대로 적용합니다.
소문자 l을 대문자 I로 변경합니다.
소문자 w를 두 개의 소문자 v, 즉 vv로 변경합니다.
대문자 W를 두 개의 대문자 V, 즉 VV로 변경합니다.
대문자 O를 숫자 0으로 변경합니다.
수정된 닉네임의 길이가 4 미만일 경우 뒤에 소문자 o를 길이가 4가 될때까지 이어붙입니다.
수정된 닉네임의 길이가 8보다 클 경우 8번째 문자까지만 사용합니다.
주어진 solution 함수에는 위의 규칙 중 올바르게 적용되지 않는 것이 있습니다. 
solution 함수가 올바르게 작동하도록 한 줄을 수정해주세요.

제한사항
1 ≤ nickname의 길이 ≤ 10
nickname은 영어 대소문자와 숫자로만 이루어져있습니다.
입출력 예
nickname	result
"WORLDworld"	"VV0RLDvv"
"GO"	"G0oo"
입출력 예 설명
입출력 예 #1
닉네임 "WORLDworld"는 1, 2, 3, 4, 6 단계를 거쳐 "VV0RLDvv"가 됩니다.
"WORLDworld" -> "WORLDworId" -> "WORLDvvorId" -> "VVORLDvvorId" -> "VV0RLDvvorId" -> "VV0RLDvv"
입출력 예 #2
닉네임 "GO"는 4, 5 단계를 거쳐 "G0oo"가 됩니다.
"GO" -> "G0" -> "G0oo"
'''




'''[저축]
문제 설명
진우는 돈을 모으기 위해 저축을 하려고 합니다. 
목표로 하는 금액은 100만 원이며, 첫 달에 일정 금액을 넣은 뒤 70만 원까지는 
매월 조금씩 저축하다가 70만 원 이후부터는 
월 저축량을 늘려 빠르게 목표 금액을 달성하고자 합니다.
첫 달에 저축하는 금액을 나타내는 정수 start, 
두 번째 달 부터 70만 원 이상 모일 때까지 매월 저축하는 금액을 나타내는 정수 before, 
100만 원 이상 모일 때 까지 매월 저축하는 금액을 나타내는 정수 after가 주어질 때, 
100만 원 이상을 모을 때까지 걸리는 개월 수를 출력하도록 빈칸을 채워 코드를 완성해 주세요.

제한사항
0 ≤ start ≤ 99
1 ≤ before ≤ after ≤ 25
입출력 예
입력 #1
28
6
8
출력 #1
12
입력 #2
75
8
25
출력 #2
2

입출력 예 설명
입출력 예 #1
매월 저축된 금액은 아래 표와 같습니다. 따라서 12를 출력합니다.
1	2	3	4	5	6	7	8	9	10	11	12
28	34	40	46	52	58	64	70	78	86	94	102
입출력 예 #2
첫 달 저축된 금액이 70이 넘으므로 두 번째 달부터 바로 after= 25 만큼 저축합니다. 
따라서 2를 출력합니다.
1	2
75	100
'''





'''[가채점]
A반 학생들은 시험이 끝난 뒤 성적이 나오기 전 자기 시험지를 
가채점해 보았습니다. 
이후에 선생님이 실제 성적을 불러 줄 때 가채점한 점수와 
실제 성적이 다른 학생들이 있어 선생님께 문의를 하려고 합니다. 
성적을 문의하려는 학생들의 번호가 담긴 정수 리스트 numbers와 
가채점한 점수가 성적을 문의하려는 학생 순서대로 담긴 정수 리스트 our_score, 
실제 성적이 번호 순서대로 담긴 정수 리스트 score_list가 주어집니다. 
주어진 solution 함수는 가채점한 점수가 실제 성적과 동일하다면 "Same"을, 
다르다면 "Different"를 순서대로 리스트에 담아 return하는 함수입니다. 
solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요.

제한사항
1 ≤ numbers의 길이 = our_score의 길이 ≤ 10
1 ≤ numbers의 원소 ≤ 31
0 ≤ our_score의 원소 ≤ 100
our_score[i]는 numbers[i]번 학생이 가채점한 점수입니다.
numbers는 중복된 원소를 가지지 않습니다.
2 ≤ score_list의 길이 ≤ 31  
0 ≤ score_list의 원소 ≤ 100
score_list에는 실제 성적이 [1번 학생 성적, 2번 학생 성적, 3번 학생 성적 …] 순서로 들어있습니다.
입출력 예
numbers	our_score	score_list	result
[1]	[100]	[100, 80, 90, 84, 20]	["Same"]
[3, 4]	[85, 93]	[85, 92, 38, 93, 48, 85, 92, 56]	["Different", "Same"]
입출력 예 설명
입출력 예 #1
1번 학생이 가채점한 성적은 100점으로 실제 성적과 같기 때문에 "Same"을 담아 return합니다.
입출력 예 #2
3번 학생이 가채점한 성적은 85점으로 실제 성적 38점과 다르기 때문에 "Different"를, 
4번 학생이 채점한 성적은 93점으로 실제 성적과 같기 때문에 "Same"을 담아 return합니다.
'''





'''[버스]
문제 설명
영진이는 약속장소에 가기 위해 버스를 타려고 합니다. 
버스에는 좌석이 총 seat개만큼 있습니다. 
영진이는 버스 좌석에 앉아서 갈 수 있을지 궁금해합니다. 
기점에서 출발한 버스가 영진이가 기다리는 정거장에 도착하기 전에 
방문하는 각 정거장에서 승/하차한 승객 정보가 주어질 때, 
영진이가 버스에 탄 순간 빈 좌석은 몇 개인지 구해주세요. 
영진이가 기다리는 정거장에서는 영진이가 제일 먼저 버스에 탑승하며, 
이전 정거장에서 버스에 탑승한 승객들은 남는 좌석이 있다면 항상 앉는다고 가정합니다. 
또, 기점에서 출발하는 버스에는 승객이 0명 타고 있습니다.

예를 들어 다음은 좌석이 5개인 버스에 각 정거장에서 승/하차한 승객 정보를 나타냅니다. 
영진이는 4번 정거장에서 기다리고 있으며, 
"On"은 승차한 승객, "Off"는 하차한 승객을 의미합니다.
- 1번 정거장 : ["On", "On", "On"] (3명 승차, 0명 하차)
- 2번 정거장 : ["Off", "On", "-"] (1명 승차, 1명 하차)
- 3번 정거장 : ["Off", "-", "-"]  (0명 승차, 1명 하차)
위와 같은 경우, 1번 정거장에서 3명이 승차하고, 
2번 정거장에서 1명 승차 1명 하차, 
3번 정거장에서 1명이 하차했으므로 
4번 정거장에 도착한 버스에는 2명이 타고 있습니다. 
4번 정거장에서는 영진이가 가장 먼저 탑승하므로, 남아있는 좌석 수는 3개입니다.
주어진 solution함수는 버스의 좌석 개수 seat, 
기점에서 출발한 버스가 순서대로 방문한 정거장에서 승객이 승/하차한 
정보를 담은 2차원 문자열 리스트 passengers가 주어질 때, 
버스에 남아있는 좌석의 개수를 return 하는 함수입니다. 
solution 함수가 올바르게 작동하도록 빈칸을 채워 solution함수를 완성해 주세요.

제한사항
1 ≤ seat ≤ 30
1 ≤ passengers의 길이 ≤ 10
1 ≤ passengers[i]의 길이 ≤ 20
passengers[0]은 1번 정거장, passengers[1]은 2번 정거장, … passengers[i]는 i + 1번 정거장의 정보입니다.
passengers의 길이가 n이라면, 영진이는 n + 1번 정거장에서 기다리고 있습니다.
passengers[i]의 길이는 모두 동일합니다.
passengers[i]의 원소는 "On", "Off" 또는 "-"입니다.
"-"는 배열의 가로(열) 길이를 맞추기 위한 요소로, 아무런 의미도 없습니다.
"-"가 "On", "Off" 사이에 있는 경우는 없습니다.
입출력 예
seat	passengers	result
5	[["On", "On", "On"], ["Off", "On", "-"], ["Off", "-", "-"]]	3
10	[["On", "On", "On", "On", "On", "On", "On", "On", "-", "-"], ["On", "On", "Off", "Off", "Off", "On", "On", "-", "-", "-"], 
["On", "On", "On", "Off", "On", "On", "On", "Off", "Off", "Off"], ["On", "On", "Off", "-", "-", "-", "-", "-", "-", "-"]]	0
입출력 예 설명
입출력 예 #1
지문과 동일합니다
입출력 예 #2
아래와 같이 승객이 타고 내렸고 마지막으로 12명이 버스에 타고 있으므로 남은 좌석은 0개입니다.
- 1번 정거장 : ["On", "On", "On", "On", "On", "On", "On", "On", "-", "-"] (8명 승차, 0명 하차)
- 2번 정거장 : ["On", "On", "Off", "Off", "Off", "On", "On", "-", "-", "-"] (4명 승차, 3명 하차)
- 3번 정거장 : ["On", "On", "On", "Off", "On", "On", "On", "Off", "Off", "Off"] (6명 승차, 4명 하차)
- 4번 정거장 : ["On", "On", "Off", "-", "-", "-", "-", "-", "-", "-"] (2명 승차, 1명 하차)
'''





'''[지폐 접기]
문제 설명
민수는 다양한 지폐를 수집하는 취미를 가지고 있습니다. 지폐마다 크기가 달라 지갑에 넣으려면 여러 번 접어서 넣어야 합니다. 
예를 들어 지갑의 크기가 30 * 15이고 지폐의 크기가 26 * 17이라면 한번 반으로 접어 13 * 17 크기로 만든 뒤 90도 돌려서 지갑에 넣을 수 있습니다. 
지폐를 접을 때는 다음과 같은 규칙을 지킵니다.
지폐를 접을 때는 항상 길이가 긴 쪽을 반으로 접습니다. 접기 전 길이가 홀수였다면 접은 후 소수점 이하는 버립니다.
접힌 지폐를 그대로 또는 90도 돌려서 지갑에 넣을 수 있다면 그만 접습니다.
지갑의 가로, 세로 크기를 담은 정수 리스트 wallet과 지폐의 가로, 세로 크기를 담은 정수 리스트 bill가 주어질 때, 지갑에 넣기 위해서 지폐를 
최소 몇 번 접어야 하는지 return하도록 solution함수를 완성해 주세요.
지폐를 지갑에 넣기 위해 접어야 하는 최소 횟수를 구하는 과정은 다음과 같습니다.
1. 지폐를 접은 횟수를 저장할 정수 변수 answer를 만들고 0을 저장합니다.
2. 반복문을 이용해 bill의 작은 값이 wallet의 작은 값 보다 크거나 bill의 큰 값이 wallet의 큰 값 보다 큰 동안 아래 과정을 반복합니다.
    2-1. bill[0]이 bill[1]보다 크다면
        bill[0]을 2로 나누고 나머지는 버립니다.
    2-2. 그렇지 않다면
        bill[1]을 2로 나누고 나머지는 버립니다.
    2-3. answer을 1 증가시킵니다.
3. answer을 return합니다.
위의 의사코드와 작동방식이 다른 코드를 작성해도 상관없습니다.
제한사항
wallet의 길이 = bill의 길이 = 2
10 ≤ wallet[0], wallet[1] ≤ 100
10 ≤ bill[0], bill[1] ≤ 2,000
입출력 예
wallet	bill	result
[30, 15]	[26, 17]	1
[50, 50]	[100, 241]	4
입출력 예 설명
입출력 예 #1
지문과 동일합니다.
입출력 예 #2
지폐를 접으면 다음과 같이 크기가 줄어듭니다. 따라서 4번 접으면 지갑에 넣을 수 있습니다.
[100, 241] -> [100, 120] -> [100, 60] -> [50, 60] -> [50, 30]
'''





'''[물 부족]
문제 설명
ㅇㅇ시에서는 저수지가 하나 있는데, 도시 내에서 사용하는 모든 물은 이 저수지에 저장된 물을 끌어와 사용합니다. 이상 기후로 인해 극심한 가뭄이 예고된 상황에서, 
지난 달의 물 사용량과 이번달부터 일정 기간 동안의 월별 물 사용량의 변화를 예측한 값을 이용해 몇 달 뒤 물이 부족해지는지 예측하려고 합니다.
이번달부터의 월별 물 사용량 변화를 예측한 값은 다음과 같이 리스트에 담겨 주어집니다.
[10, -10, 10, -10, 10, -10, 10, -10, 10, -10]
리스트의 각 원소는 해당 월의 물 사용량이 전 달에 비해 몇 % 만큼 증가 또는 감소하는지를 나타냅니다.
예를 들어, 이번달의 물 사용량 (리스트의 첫 번째 원소)은 지난 달 보다 10% 증가한 값이며, 다음 달(리스트의 두 번째 원소)의 물 사용량은 이번달 사용량에서 10%만큼 감소한 값입니다.
자세한 값은 입출력 예시를 참고해 주세요.
현재 저수지에 저장된 물의 양을 나타내는 정수 storage와 지난 달 물 사용량을 나타내는 정수 usage, 월별 물 사용량이 전 달 대비 어떻게 변하는지 
저장된 정수 리스트 change가 주어질 때 몇 달 뒤 물이 부족해지는지 return 하도록 solution 함수를 작성하려 합니다. 코드가 올바르게 작동하도록 
한 줄을 수정해 solution 함수를 완성해 주세요. 가뭄이 끝날때 까지 저수지의 물이 남아 있다면 -1을 return합니다.

제한사항
1,000 ≤ storage ≤ 1,000,000
500 ≤ usage ≤ 30,000
1 ≤ change의 길이 ≤ 30
-99 ≤ change[i] ≤ 500
change[i] 가 양수일 경우 물 사용량은 전 달 보다 change[i]% 만큼 증가합니다.
change[i] 가 음수일 경우 물 사용량은 전 달 보다 change[i]% 만큼 감소합니다.
change[i] 가 0일 경우 물 사용량은 전 달과 동일합니다.
매달 물 사용량은 소수점 이하를 버린 정수로 계산합니다.
입출력 예
storage	usage	change	result
5141	500	[10, -10, 10, -10, 10, -10, 10, -10, 10, -10]	-1
1000	2000	[-10, 25, -33]	1
입출력 예 설명
입출력 예 #1

매월 물 사용량은 다음과 같습니다.
n개월 뒤	0 (이번 달)	1 (다음 달)	2	3	4	5	6	7	8	9
월 별 물 사용량	550	495	544	490	539	485	533	479	526	474
총 물 사용량	550	1045	1589	2079	2618	3103	3636	4115	4641	5115
예를 들어, 지난 달 물 사용량 usage = 500이므로, 이번달 물 사용량은 10% 증가한 550입니다. 다음 달 물 사용량은 이번달 사용량 550에서 10% 감소한 495 이며, 나머지 달도 동일하게 계산합니다. 9달 뒤까지 계산한 물 사용량은 총 5115 이며, 현재 저수지에 저장된 물의 양은 storage = 5141입니다. 따라서 물이 부족해지지 않으므로 -1을 return합니다.
입출력 예 #2

총 사용가능한 물의 양이 1000인데 2000 * 0.9 = 1800이 필요하므로 이번 달부터 물이 부족합니다. 따라서 0을 return합니다.
'''





'''[창고 정리]
문제 설명
선빈이는 게임을 즐기던 중 가지고 있는 물건이 너무 많아 창고 정리를 하기로 했습니다. 선빈이가 보유한 게임 속 창고는 여러 칸으로 나누어져 있고 
각 칸에는 물건들이 담겨있습니다. 창고를 정리할 방법을 고민하던 선빈이는 같은 물건이 여러 칸에 나누어 들어있는 것을 발견하고 우선 같은 물건끼리 
최대한 겹쳐쌓는 방식으로 창고를 정리하기로 했습니다. 선빈이의 창고에 들어있는 물건의 이름과 개수는 리스트 형태로 주어지며, 한 칸에 겹쳐질 수 있는 
물건의 개수에는 제한이 없다고 가정합니다.
예를 들어 창고의 각 칸에 담겨있는 물건의 이름이storage = ["pencil", "pencil", "pencil", "book"], 각 물건의 개수가 num = [2, 4, 3, 1]이라면 
연필과 책을 한 칸에 각각 겹쳐 쌓아 간단하게 clean_storage = ["pencil", "book"], clean_num = [9, 1]로 만들 수 있습니다.
주어진 solution 함수는 정리되기 전 창고의 물건 이름이 담긴 문자열 리스트 storage와 각 물건의 개수가 담긴 정수 리스트 num이 주어질 때, 
정리된 창고에서 개수가 가장 많은 물건의 이름을 return 하는 함수입니다. solution 함수가 올바르게 작동하도록 한 줄을 수정해 주세요.

제한사항
1 ≤ storage의 길이 = num의 길이 ≤ 30
storage[i]는 영어 대소문자로 이루어져 있습니다.
물건은 대소문자를 구분합니다. 즉, "Book"과 "book"은 서로 다른 물건입니다.
1 ≤ storage[i]의 길이 ≤ 30
1 ≤ num[i] ≤ 20
num[i]에는 storage[i]에 해당하는 물건의 개수가 담겨있습니다.
가장 개수가 많은 물건이 두 가지 이상인 경우는 없습니다.
한 칸에는 한 종류의 물건만 들어갈 수 있습니다.
입출력 예
storage	num	result
["pencil", "pencil", "pencil", "book"]	[2, 4, 3, 1]	"pencil"
["doll", "doll", "doll", "doll"]	[1, 1, 1, 1]	"doll"
["apple", "steel", "leaf", "apple", "leaf"]	[5, 3, 5, 3, 7]	"leaf"
["mirror", "net", "mirror", "net", "bottle"]	[4, 1, 4, 1, 5]	"mirror"
입출력 예 설명
입출력 예 #1
본문에 설명된 대로 창고를 정리하면 clean_storage = ["pencil", "book"], clean_num = [9, 1]이 됩니다. 따라서 가장 개수가 많은 물건인 "pencil"을 return합니다.
입출력 예 #2
창고를 정리하면 clean_storage = ["doll"], clean_num = [4]가 됩니다. 따라서 가장 개수가 많은 물건인 "doll"을 return합니다.
입출력 예 #3
창고를 정리하면 clean_storage = ["apple", "steel", "leaf"], clean_num = [8, 3, 12]가 됩니다. 따라서 가장 개수가 많은 물건인 "leaf"를 return합니다.
입출력 예 #4
창고를 정리하면 clean_storage = ["mirror", "net", "bottle"], clean_num = [8, 2, 5]가 됩니다. 따라서 가장 개수가 많은 물건인 "mirror"를 return합니다.
'''






'''[동영상 재생기]
문제 설명
당신은 동영상 재생기를 만들고 있습니다. 당신의 동영상 재생기는 10초 전으로 이동, 10초 후로 이동, 오프닝 건너뛰기 3가지 기능을 지원합니다. 
각 기능이 수행하는 작업은 다음과 같습니다.
•	10초 전으로 이동: 사용자가 "prev" 명령을 입력할 경우 동영상의 재생 위치를 현재 위치에서 10초 전으로 이동합니다. 현재 위치가 10초 미만인 
경우 영상의 처음 위치로 이동합니다. 영상의 처음 위치는 0분 0초입니다.
•	10초 후로 이동: 사용자가 "next" 명령을 입력할 경우 동영상의 재생 위치를 현재 위치에서 10초 후로 이동합니다. 동영상의 남은 시간이 10초 미만일 경우 
영상의 마지막 위치로 이동합니다. 영상의 마지막 위치는 동영상의 길이와 같습니다.
•	오프닝 건너뛰기: 현재 재생 위치가 오프닝 구간(op_start ≤ 현재 재생 위치 ≤ op_end)인 경우 자동으로 오프닝이 끝나는 위치로 이동합니다.
동영상의 길이를 나타내는 문자열 video_len, 기능이 수행되기 직전의 재생위치를 나타내는 문자열 pos, 오프닝 시작 시각을 나타내는 문자열 op_start, 
오프닝이 끝나는 시각을 나타내는 문자열 op_end, 사용자의 입력을 나타내는 1차원 문자열 배열 commands가 매개변수로 주어집니다. 이때 사용자의 입력이 모두 끝난 
후 동영상의 위치를 "mm:ss" 형식으로 return 하도록 solution 함수를 완성해 주세요.

제한사항
•	video_len의 길이 = pos의 길이 = op_start의 길이 = op_end의 길이 = 5
•	video_len, pos, op_start, op_end는 "mm:ss" 형식으로 mm분 ss초를 나타냅니다.
•	0 ≤ mm ≤ 59
•	0 ≤ ss ≤ 59
•	분, 초가 한 자리일 경우 0을 붙여 두 자리로 나타냅니다.
•	비디오의 현재 위치 혹은 오프닝이 끝나는 시각이 동영상의 범위 밖인 경우는 주어지지 않습니다.
•	오프닝이 시작하는 시각은 항상 오프닝이 끝나는 시각보다 전입니다.
•	1 ≤ commands의 길이 ≤ 100
•	commands의 원소는 "prev" 혹은 "next"입니다.
•	"prev"는 10초 전으로 이동하는 명령입니다.
•	"next"는 10초 후로 이동하는 명령입니다.

입출력 예
video_len	pos	op_start	op_end	commands	result
"34:33"	"13:00"	"00:55"	"02:55"	["next", "prev"]	"13:00"
"10:55"	"00:05"	"00:15"	"06:55"	["prev", "next", "next"]	"06:55"
"07:22"	"04:05"	"00:15"	"04:07"	["next"]	"04:17"
입출력 예 설명
입출력 예 #1
•	시작 위치 13분 0초에서 10초 후로 이동하면 13분 10초입니다.
•	13분 10초에서 10초 전으로 이동하면 13분 0초입니다.
•	따라서 "13:00"을 return 하면 됩니다.
입출력 예 #2
•	시작 위치 0분 5초에서 10초 전으로 이동합니다. 현재 위치가 10초 미만이기 때문에 0분 0초로 이동합니다.
•	0분 0초에서 10초 후로 이동하면 0분 10초입니다.
•	0분 10초에서 10초 후로 이동하면 0분 20초입니다. 0분 20초는 오프닝 구간이기 때문에 오프닝이 끝나는 위치인 6분 55초로 이동합니다. 따라서 "06:55"를 return 하면 됩니다.
입출력 예 #3
•	시작 위치 4분 5초는 오프닝 구간이기 때문에 오프닝이 끝나는 위치인 4분 7초로 이동합니다. 4분 7초에서 10초 후로 이동하면 4분 17초입니다. 따라서 "04:17"을 return 하면 됩니다.
'''
